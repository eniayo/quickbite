"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachedDataSource = exports.WebsiteNoticeDataSource = exports.FilteredNotice = exports.Notices = exports.NoticesFilter = void 0;
const https = require("node:https");
const path = require("path");
const fs = require("fs-extra");
const semver = require("semver");
const awscli_compatible_1 = require("./api/aws-auth/awscli-compatible");
const version_1 = require("./cli/version");
const logging_1 = require("./logging");
const error_1 = require("./toolkit/error");
const tree_1 = require("./tree");
const directories_1 = require("./util/directories");
const format_error_1 = require("./util/format-error");
const CACHE_FILE_PATH = path.join((0, directories_1.cdkCacheDir)(), 'notices.json');
class NoticesFilter {
    static filter(options) {
        const components = [
            ...NoticesFilter.constructTreeComponents(options.outDir),
            ...NoticesFilter.otherComponents(options),
        ];
        return NoticesFilter.findForNamedComponents(options.data, components);
    }
    /**
     * From a set of input options, return the notices components we are searching for
     */
    static otherComponents(options) {
        return [
            // CLI
            {
                name: 'cli',
                version: options.cliVersion,
            },
            // Node version
            {
                name: 'node',
                version: process.version.replace(/^v/, ''), // remove the 'v' prefix.
                dynamicName: 'node',
            },
            // Bootstrap environments
            ...options.bootstrappedEnvironments.flatMap(env => {
                const semverBootstrapVersion = semver.coerce(env.bootstrapStackVersion);
                if (!semverBootstrapVersion) {
                    // we don't throw because notices should never crash the cli.
                    (0, logging_1.warning)(`While filtering notices, could not coerce bootstrap version '${env.bootstrapStackVersion}' into semver`);
                    return [];
                }
                return [{
                        name: 'bootstrap',
                        version: `${semverBootstrapVersion}`,
                        dynamicName: 'ENVIRONMENTS',
                        dynamicValue: env.environment.name,
                    }];
            }),
        ];
    }
    /**
     * Based on a set of component names, find all notices that match one of the given components
     */
    static findForNamedComponents(data, actualComponents) {
        return data.flatMap(notice => {
            const ors = this.resolveAliases(normalizeComponents(notice.components));
            // Find the first set of the disjunctions of which all components match against the actual components.
            // Return the actual components we found so that we can inject their dynamic values. A single filter
            // component can match more than one actual component
            for (const ands of ors) {
                const matched = ands.map(affected => actualComponents.filter(actual => NoticesFilter.componentNameMatches(affected, actual) && semver.satisfies(actual.version, affected.version)));
                // For every clause in the filter we matched one or more components
                if (matched.every(xs => xs.length > 0)) {
                    const ret = new FilteredNotice(notice);
                    NoticesFilter.addDynamicValues(matched.flatMap(x => x), ret);
                    return [ret];
                }
            }
            return [];
        });
    }
    /**
     * Whether the given "affected component" name applies to the given actual component name.
     *
     * The name matches if the name is exactly the same, or the name in the notice
     * is a prefix of the node name when the query ends in '.'.
     */
    static componentNameMatches(pattern, actual) {
        return pattern.name.endsWith('.') ? actual.name.startsWith(pattern.name) : pattern.name === actual.name;
    }
    /**
     * Adds dynamic values from the given ActualComponents
     *
     * If there are multiple components with the same dynamic name, they are joined
     * by a comma.
     */
    static addDynamicValues(comps, notice) {
        var _a, _b;
        const dynamicValues = {};
        for (const comp of comps) {
            if (comp.dynamicName) {
                dynamicValues[comp.dynamicName] = (_a = dynamicValues[comp.dynamicName]) !== null && _a !== void 0 ? _a : [];
                dynamicValues[comp.dynamicName].push((_b = comp.dynamicValue) !== null && _b !== void 0 ? _b : comp.version);
            }
        }
        for (const [key, values] of Object.entries(dynamicValues)) {
            notice.addDynamicValue(key, values.join(','));
        }
    }
    /**
     * Treat 'framework' as an alias for either `aws-cdk-lib.` or `@aws-cdk/core.`.
     *
     * Because it's EITHER `aws-cdk-lib` or `@aws-cdk/core`, we need to add multiple
     * arrays at the top level.
     */
    static resolveAliases(ors) {
        return ors.flatMap(ands => {
            const hasFramework = ands.find(c => c.name === 'framework');
            if (!hasFramework) {
                return [ands];
            }
            return [
                ands.map(c => c.name === 'framework' ? { ...c, name: '@aws-cdk/core.' } : c),
                ands.map(c => c.name === 'framework' ? { ...c, name: 'aws-cdk-lib.' } : c),
            ];
        });
    }
    /**
     * Load the construct tree from the given directory and return its components
     */
    static constructTreeComponents(manifestDir) {
        const tree = (0, tree_1.loadTreeFromDir)(manifestDir);
        if (!tree) {
            return [];
        }
        const ret = [];
        recurse(tree);
        return ret;
        function recurse(x) {
            var _a, _b, _c, _d, _e;
            if (((_a = x.constructInfo) === null || _a === void 0 ? void 0 : _a.fqn) && ((_b = x.constructInfo) === null || _b === void 0 ? void 0 : _b.version)) {
                ret.push({
                    name: (_c = x.constructInfo) === null || _c === void 0 ? void 0 : _c.fqn,
                    version: (_d = x.constructInfo) === null || _d === void 0 ? void 0 : _d.version,
                });
            }
            for (const child of Object.values((_e = x.children) !== null && _e !== void 0 ? _e : {})) {
                recurse(child);
            }
        }
    }
}
exports.NoticesFilter = NoticesFilter;
/**
 * Provides access to notices the CLI can display.
 */
class Notices {
    /**
     * Create an instance. Note that this replaces the singleton.
     */
    static create(props) {
        this._instance = new Notices(props);
        return this._instance;
    }
    /**
     * Get the singleton instance. May return `undefined` if `create` has not been called.
     */
    static get() {
        return this._instance;
    }
    constructor(props) {
        var _a, _b, _c, _d, _e;
        this.data = new Set();
        // sets don't deduplicate interfaces, so we use a map.
        this.bootstrappedEnvironments = new Map();
        this.context = props.context;
        this.acknowledgedIssueNumbers = new Set((_a = this.context.get('acknowledged-issue-numbers')) !== null && _a !== void 0 ? _a : []);
        this.includeAcknowlegded = (_b = props.includeAcknowledged) !== null && _b !== void 0 ? _b : false;
        this.output = (_c = props.output) !== null && _c !== void 0 ? _c : 'cdk.out';
        this.shouldDisplay = (_d = props.shouldDisplay) !== null && _d !== void 0 ? _d : true;
        this.httpOptions = (_e = props.httpOptions) !== null && _e !== void 0 ? _e : {};
    }
    /**
     * Add a bootstrap information to filter on. Can have multiple values
     * in case of multi-environment deployments.
     */
    addBootstrappedEnvironment(bootstrapped) {
        const key = [
            bootstrapped.bootstrapStackVersion,
            bootstrapped.environment.account,
            bootstrapped.environment.region,
            bootstrapped.environment.name,
        ].join(':');
        this.bootstrappedEnvironments.set(key, bootstrapped);
    }
    /**
     * Refresh the list of notices this instance is aware of.
     * To make sure this never crashes the CLI process, all failures are caught and
     * silently logged.
     *
     * If context is configured to not display notices, this will no-op.
     */
    async refresh(options = {}) {
        var _a, _b;
        if (!this.shouldDisplay) {
            return;
        }
        try {
            const underlyingDataSource = (_a = options.dataSource) !== null && _a !== void 0 ? _a : new WebsiteNoticeDataSource(this.httpOptions);
            const dataSource = new CachedDataSource(CACHE_FILE_PATH, underlyingDataSource, (_b = options.force) !== null && _b !== void 0 ? _b : false);
            const notices = await dataSource.fetch();
            this.data = new Set(this.includeAcknowlegded ? notices : notices.filter(n => !this.acknowledgedIssueNumbers.has(n.issueNumber)));
        }
        catch (e) {
            (0, logging_1.debug)(`Could not refresh notices: ${e}`);
        }
    }
    /**
     * Display the relevant notices (unless context dictates we shouldn't).
     */
    display(options = {}) {
        var _a;
        if (!this.shouldDisplay) {
            return;
        }
        const filteredNotices = NoticesFilter.filter({
            data: Array.from(this.data),
            cliVersion: (0, version_1.versionNumber)(),
            outDir: this.output,
            bootstrappedEnvironments: Array.from(this.bootstrappedEnvironments.values()),
        });
        if (filteredNotices.length > 0) {
            (0, logging_1.info)('');
            (0, logging_1.info)('NOTICES         (What\'s this? https://github.com/aws/aws-cdk/wiki/CLI-Notices)');
            (0, logging_1.info)('');
            for (const filtered of filteredNotices) {
                const formatted = filtered.format();
                switch (filtered.notice.severity) {
                    case 'warning':
                        (0, logging_1.warning)(formatted);
                        break;
                    case 'error':
                        (0, logging_1.error)(formatted);
                        break;
                    default:
                        (0, logging_1.info)(formatted);
                }
                (0, logging_1.info)('');
            }
            (0, logging_1.info)(`If you don’t want to see a notice anymore, use "cdk acknowledge <id>". For example, "cdk acknowledge ${filteredNotices[0].notice.issueNumber}".`);
        }
        if ((_a = options.showTotal) !== null && _a !== void 0 ? _a : false) {
            (0, logging_1.info)('');
            (0, logging_1.info)(`There are ${filteredNotices.length} unacknowledged notice(s).`);
        }
    }
}
exports.Notices = Notices;
/**
 * Normalizes the given components structure into DNF form
 */
function normalizeComponents(xs) {
    return xs.map(x => Array.isArray(x) ? x : [x]);
}
function renderConjunction(xs) {
    return xs.map(c => `${c.name}: ${c.version}`).join(' AND ');
}
/**
 * Notice after passing the filter. A filter can augment a notice with
 * dynamic values as it has access to the dynamic matching data.
 */
class FilteredNotice {
    constructor(notice) {
        this.notice = notice;
        this.dynamicValues = {};
    }
    addDynamicValue(key, value) {
        this.dynamicValues[`{resolve:${key}}`] = value;
    }
    format() {
        const componentsValue = normalizeComponents(this.notice.components).map(renderConjunction).join(', ');
        return this.resolveDynamicValues([
            `${this.notice.issueNumber}\t${this.notice.title}`,
            this.formatOverview(),
            `\tAffected versions: ${componentsValue}`,
            `\tMore information at: https://github.com/aws/aws-cdk/issues/${this.notice.issueNumber}`,
        ].join('\n\n') + '\n');
    }
    formatOverview() {
        const wrap = (s) => s.replace(/(?![^\n]{1,60}$)([^\n]{1,60})\s/g, '$1\n');
        const heading = 'Overview: ';
        const separator = `\n\t${' '.repeat(heading.length)}`;
        const content = wrap(this.notice.overview)
            .split('\n')
            .join(separator);
        return '\t' + heading + content;
    }
    resolveDynamicValues(input) {
        const pattern = new RegExp(Object.keys(this.dynamicValues).join('|'), 'g');
        return input.replace(pattern, (matched) => { var _a; return (_a = this.dynamicValues[matched]) !== null && _a !== void 0 ? _a : matched; });
    }
}
exports.FilteredNotice = FilteredNotice;
class WebsiteNoticeDataSource {
    constructor(options = {}) {
        this.options = options;
    }
    fetch() {
        const timeout = 3000;
        return new Promise((resolve, reject) => {
            let req;
            let timer = setTimeout(() => {
                if (req) {
                    req.destroy(new error_1.ToolkitError('Request timed out'));
                }
            }, timeout);
            timer.unref();
            const options = {
                agent: awscli_compatible_1.AwsCliCompatible.proxyAgent(this.options),
            };
            try {
                req = https.get('https://cli.cdk.dev-tools.aws.dev/notices.json', options, res => {
                    if (res.statusCode === 200) {
                        res.setEncoding('utf8');
                        let rawData = '';
                        res.on('data', (chunk) => {
                            rawData += chunk;
                        });
                        res.on('end', () => {
                            try {
                                const data = JSON.parse(rawData).notices;
                                if (!data) {
                                    throw new error_1.ToolkitError("'notices' key is missing");
                                }
                                (0, logging_1.debug)('Notices refreshed');
                                resolve(data !== null && data !== void 0 ? data : []);
                            }
                            catch (e) {
                                reject(new error_1.ToolkitError(`Failed to parse notices: ${(0, format_error_1.formatErrorMessage)(e)}`));
                            }
                        });
                        res.on('error', e => {
                            reject(new error_1.ToolkitError(`Failed to fetch notices: ${(0, format_error_1.formatErrorMessage)(e)}`));
                        });
                    }
                    else {
                        reject(new error_1.ToolkitError(`Failed to fetch notices. Status code: ${res.statusCode}`));
                    }
                });
                req.on('error', reject);
            }
            catch (e) {
                reject(new error_1.ToolkitError(`HTTPS 'get' call threw an error: ${(0, format_error_1.formatErrorMessage)(e)}`));
            }
        });
    }
}
exports.WebsiteNoticeDataSource = WebsiteNoticeDataSource;
const TIME_TO_LIVE_SUCCESS = 60 * 60 * 1000; // 1 hour
const TIME_TO_LIVE_ERROR = 1 * 60 * 1000; // 1 minute
class CachedDataSource {
    constructor(fileName, dataSource, skipCache) {
        this.fileName = fileName;
        this.dataSource = dataSource;
        this.skipCache = skipCache;
    }
    async fetch() {
        var _a;
        const cachedData = await this.load();
        const data = cachedData.notices;
        const expiration = (_a = cachedData.expiration) !== null && _a !== void 0 ? _a : 0;
        if (Date.now() > expiration || this.skipCache) {
            const freshData = await this.fetchInner();
            await this.save(freshData);
            return freshData.notices;
        }
        else {
            (0, logging_1.debug)(`Reading cached notices from ${this.fileName}`);
            return data;
        }
    }
    async fetchInner() {
        try {
            return {
                expiration: Date.now() + TIME_TO_LIVE_SUCCESS,
                notices: await this.dataSource.fetch(),
            };
        }
        catch (e) {
            (0, logging_1.debug)(`Could not refresh notices: ${e}`);
            return {
                expiration: Date.now() + TIME_TO_LIVE_ERROR,
                notices: [],
            };
        }
    }
    async load() {
        const defaultValue = {
            expiration: 0,
            notices: [],
        };
        try {
            return fs.existsSync(this.fileName)
                ? await fs.readJSON(this.fileName)
                : defaultValue;
        }
        catch (e) {
            (0, logging_1.debug)(`Failed to load notices from cache: ${e}`);
            return defaultValue;
        }
    }
    async save(cached) {
        try {
            await fs.writeJSON(this.fileName, cached);
        }
        catch (e) {
            (0, logging_1.debug)(`Failed to store notices in the cache: ${e}`);
        }
    }
}
exports.CachedDataSource = CachedDataSource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90aWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm5vdGljZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsb0NBQW9DO0FBQ3BDLDZCQUE2QjtBQUU3QiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBRWpDLHdFQUFvRTtBQUVwRSwyQ0FBOEM7QUFDOUMsdUNBQXdEO0FBQ3hELDJDQUErQztBQUMvQyxpQ0FBNEQ7QUFDNUQsb0RBQWlEO0FBQ2pELHNEQUF5RDtBQUV6RCxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUEseUJBQVcsR0FBRSxFQUFFLGNBQWMsQ0FBQyxDQUFDO0FBb0VqRSxNQUFzQixhQUFhO0lBQzFCLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBbUM7UUFDdEQsTUFBTSxVQUFVLEdBQUc7WUFDakIsR0FBRyxhQUFhLENBQUMsdUJBQXVCLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUN4RCxHQUFHLGFBQWEsQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDO1NBQzFDLENBQUM7UUFFRixPQUFPLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRDs7T0FFRztJQUNLLE1BQU0sQ0FBQyxlQUFlLENBQUMsT0FBbUM7UUFDaEUsT0FBTztZQUNMLE1BQU07WUFDTjtnQkFDRSxJQUFJLEVBQUUsS0FBSztnQkFDWCxPQUFPLEVBQUUsT0FBTyxDQUFDLFVBQVU7YUFDNUI7WUFFRCxlQUFlO1lBQ2Y7Z0JBQ0UsSUFBSSxFQUFFLE1BQU07Z0JBQ1osT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSx5QkFBeUI7Z0JBQ3JFLFdBQVcsRUFBRSxNQUFNO2FBQ3BCO1lBRUQseUJBQXlCO1lBQ3pCLEdBQUcsT0FBTyxDQUFDLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxHQUFH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Q0FBQztJQUNILENBQUM7SUFFTyxLQUFLLENBQUMsSUFBSTtRQUNoQixNQUFNLFlBQVksR0FBRztZQUNuQixVQUFVLEVBQUUsQ0FBQztZQUNiLE9BQU8sRUFBRSxFQUFFO1NBQ1osQ0FBQztRQUVGLElBQUksQ0FBQztZQUNILE9BQU8sRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO2dCQUNqQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQWtCO2dCQUNuRCxDQUFDLENBQUMsWUFBWSxDQUFDO1FBQ25CLENBQUM7UUFBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQ1gsSUFBQSxlQUFLLEVBQUMsc0NBQXNDLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDakQsT0FBTyxZQUFZLENBQUM7UUFDdEIsQ0FBQztJQUNILENBQUM7SUFFTyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQXFCO1FBQ3RDLElBQUksQ0FBQztZQUNILE1BQU0sRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzVDLENBQUM7UUFBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQ1gsSUFBQSxlQUFLLEVBQUMseUNBQXlDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEQsQ0FBQztJQUNILENBQUM7Q0FDRjtBQTVERCw0Q0E0REMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDbGllbnRSZXF1ZXN0IH0gZnJvbSAnaHR0cCc7XG5pbXBvcnQgeyBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJ2h0dHBzJztcbmltcG9ydCAqIGFzIGh0dHBzIGZyb20gJ25vZGU6aHR0cHMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB0eXBlIHsgRW52aXJvbm1lbnQgfSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgeyBTZGtIdHRwT3B0aW9ucyB9IGZyb20gJy4vYXBpJztcbmltcG9ydCB7IEF3c0NsaUNvbXBhdGlibGUgfSBmcm9tICcuL2FwaS9hd3MtYXV0aC9hd3NjbGktY29tcGF0aWJsZSc7XG5pbXBvcnQgdHlwZSB7IENvbnRleHQgfSBmcm9tICcuL2FwaS9jb250ZXh0JztcbmltcG9ydCB7IHZlcnNpb25OdW1iZXIgfSBmcm9tICcuL2NsaS92ZXJzaW9uJztcbmltcG9ydCB7IGRlYnVnLCBpbmZvLCB3YXJuaW5nLCBlcnJvciB9IGZyb20gJy4vbG9nZ2luZyc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuL3Rvb2xraXQvZXJyb3InO1xuaW1wb3J0IHsgQ29uc3RydWN0VHJlZU5vZGUsIGxvYWRUcmVlRnJvbURpciB9IGZyb20gJy4vdHJlZSc7XG5pbXBvcnQgeyBjZGtDYWNoZURpciB9IGZyb20gJy4vdXRpbC9kaXJlY3Rvcmllcyc7XG5pbXBvcnQgeyBmb3JtYXRFcnJvck1lc3NhZ2UgfSBmcm9tICcuL3V0aWwvZm9ybWF0LWVycm9yJztcblxuY29uc3QgQ0FDSEVfRklMRV9QQVRIID0gcGF0aC5qb2luKGNka0NhY2hlRGlyKCksICdub3RpY2VzLmpzb24nKTtcblxuZXhwb3J0IGludGVyZmFjZSBOb3RpY2VzUHJvcHMge1xuICAvKipcbiAgICogQ0RLIGNvbnRleHRcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRleHQ6IENvbnRleHQ7XG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgbm90aWNlcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFja25vd2xlZGdlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGluY2x1ZGVBY2tub3dsZWRnZWQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBHbG9iYWwgQ0xJIG9wdGlvbiBmb3Igb3V0cHV0IGRpcmVjdG9yeSBmb3Igc3ludGhlc2l6ZWQgY2xvdWQgYXNzZW1ibHlcbiAgICpcbiAgICogQGRlZmF1bHQgJ2Nkay5vdXQnXG4gICAqL1xuICByZWFkb25seSBvdXRwdXQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEdsb2JhbCBDTEkgb3B0aW9uIGZvciB3aGV0aGVyIHdlIHNob3cgbm90aWNlc1xuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBzaG91bGREaXNwbGF5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgdGhlIEhUVFAgcmVxdWVzdFxuICAgKi9cbiAgcmVhZG9ubHkgaHR0cE9wdGlvbnM/OiBTZGtIdHRwT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RpY2VzUHJpbnRPcHRpb25zIHtcblxuICAvKipcbiAgICogV2hldGhlciB0byBhcHBlbmQgdGhlIHRvdGFsIG51bWJlciBvZiB1bmFja25vd2xlZGdlZCBub3RpY2VzIHRvIHRoZSBkaXNwbGF5LlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgc2hvd1RvdGFsPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RpY2VzUmVmcmVzaE9wdGlvbnMge1xuICAvKipcbiAgICogV2hldGhlciB0byBmb3JjZSBhIGNhY2hlIHJlZnJlc2ggcmVnYXJkbGVzcyBvZiBleHBpcmF0aW9uIHRpbWUuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBmb3JjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERhdGEgc291cmNlIGZvciBmZXRjaCBub3RpY2VzIGZyb20uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gV2Vic2l0ZU5vdGljZURhdGFTb3VyY2VcbiAgICovXG4gIHJlYWRvbmx5IGRhdGFTb3VyY2U/OiBOb3RpY2VEYXRhU291cmNlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGljZXNGaWx0ZXJGaWx0ZXJPcHRpb25zIHtcbiAgcmVhZG9ubHkgZGF0YTogTm90aWNlW107XG4gIHJlYWRvbmx5IGNsaVZlcnNpb246IHN0cmluZztcbiAgcmVhZG9ubHkgb3V0RGlyOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGJvb3RzdHJhcHBlZEVudmlyb25tZW50czogQm9vdHN0cmFwcGVkRW52aXJvbm1lbnRbXTtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE5vdGljZXNGaWx0ZXIge1xuICBwdWJsaWMgc3RhdGljIGZpbHRlcihvcHRpb25zOiBOb3RpY2VzRmlsdGVyRmlsdGVyT3B0aW9ucyk6IEZpbHRlcmVkTm90aWNlW10ge1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBbXG4gICAgICAuLi5Ob3RpY2VzRmlsdGVyLmNvbnN0cnVjdFRyZWVDb21wb25lbnRzKG9wdGlvbnMub3V0RGlyKSxcbiAgICAgIC4uLk5vdGljZXNGaWx0ZXIub3RoZXJDb21wb25lbnRzKG9wdGlvbnMpLFxuICAgIF07XG5cbiAgICByZXR1cm4gTm90aWNlc0ZpbHRlci5maW5kRm9yTmFtZWRDb21wb25lbnRzKG9wdGlvbnMuZGF0YSwgY29tcG9uZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogRnJvbSBhIHNldCBvZiBpbnB1dCBvcHRpb25zLCByZXR1cm4gdGhlIG5vdGljZXMgY29tcG9uZW50cyB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgb3RoZXJDb21wb25lbnRzKG9wdGlvbnM6IE5vdGljZXNGaWx0ZXJGaWx0ZXJPcHRpb25zKTogQWN0dWFsQ29tcG9uZW50W10ge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBDTElcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsaScsXG4gICAgICAgIHZlcnNpb246IG9wdGlvbnMuY2xpVmVyc2lvbixcbiAgICAgIH0sXG5cbiAgICAgIC8vIE5vZGUgdmVyc2lvblxuICAgICAge1xuICAgICAgICBuYW1lOiAnbm9kZScsXG4gICAgICAgIHZlcnNpb246IHByb2Nlc3MudmVyc2lvbi5yZXBsYWNlKC9edi8sICcnKSwgLy8gcmVtb3ZlIHRoZSAndicgcHJlZml4LlxuICAgICAgICBkeW5hbWljTmFtZTogJ25vZGUnLFxuICAgICAgfSxcblxuICAgICAgLy8gQm9vdHN0cmFwIGVudmlyb25tZW50c1xuICAgICAgLi4ub3B0aW9ucy5ib290c3RyYXBwZWRFbnZpcm9ubWVudHMuZmxhdE1hcChlbnYgPT4ge1xuICAgICAgICBjb25zdCBzZW12ZXJCb290c3RyYXBWZXJzaW9uID0gc2VtdmVyLmNvZXJjZShlbnYuYm9vdHN0cmFwU3RhY2tWZXJzaW9uKTtcbiAgICAgICAgaWYgKCFzZW12ZXJCb290c3RyYXBWZXJzaW9uKSB7XG4gICAgICAgICAgLy8gd2UgZG9uJ3QgdGhyb3cgYmVjYXVzZSBub3RpY2VzIHNob3VsZCBuZXZlciBjcmFzaCB0aGUgY2xpLlxuICAgICAgICAgIHdhcm5pbmcoYFdoaWxlIGZpbHRlcmluZyBub3RpY2VzLCBjb3VsZCBub3QgY29lcmNlIGJvb3RzdHJhcCB2ZXJzaW9uICcke2Vudi5ib290c3RyYXBTdGFja1ZlcnNpb259JyBpbnRvIHNlbXZlcmApO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgIG5hbWU6ICdib290c3RyYXAnLFxuICAgICAgICAgIHZlcnNpb246IGAke3NlbXZlckJvb3RzdHJhcFZlcnNpb259YCxcbiAgICAgICAgICBkeW5hbWljTmFtZTogJ0VOVklST05NRU5UUycsXG4gICAgICAgICAgZHluYW1pY1ZhbHVlOiBlbnYuZW52aXJvbm1lbnQubmFtZSxcbiAgICAgICAgfV07XG4gICAgICB9KSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhc2VkIG9uIGEgc2V0IG9mIGNvbXBvbmVudCBuYW1lcywgZmluZCBhbGwgbm90aWNlcyB0aGF0IG1hdGNoIG9uZSBvZiB0aGUgZ2l2ZW4gY29tcG9uZW50c1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZmluZEZvck5hbWVkQ29tcG9uZW50cyhkYXRhOiBOb3RpY2VbXSwgYWN0dWFsQ29tcG9uZW50czogQWN0dWFsQ29tcG9uZW50W10pOiBGaWx0ZXJlZE5vdGljZVtdIHtcbiAgICByZXR1cm4gZGF0YS5mbGF0TWFwKG5vdGljZSA9PiB7XG4gICAgICBjb25zdCBvcnMgPSB0aGlzLnJlc29sdmVBbGlhc2VzKG5vcm1hbGl6ZUNvbXBvbmVudHMobm90aWNlLmNvbXBvbmVudHMpKTtcblxuICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgc2V0IG9mIHRoZSBkaXNqdW5jdGlvbnMgb2Ygd2hpY2ggYWxsIGNvbXBvbmVudHMgbWF0Y2ggYWdhaW5zdCB0aGUgYWN0dWFsIGNvbXBvbmVudHMuXG4gICAgICAvLyBSZXR1cm4gdGhlIGFjdHVhbCBjb21wb25lbnRzIHdlIGZvdW5kIHNvIHRoYXQgd2UgY2FuIGluamVjdCB0aGVpciBkeW5hbWljIHZhbHVlcy4gQSBzaW5nbGUgZmlsdGVyXG4gICAgICAvLyBjb21wb25lbnQgY2FuIG1hdGNoIG1vcmUgdGhhbiBvbmUgYWN0dWFsIGNvbXBvbmVudFxuICAgICAgZm9yIChjb25zdCBhbmRzIG9mIG9ycykge1xuICAgICAgICBjb25zdCBtYXRjaGVkID0gYW5kcy5tYXAoYWZmZWN0ZWQgPT4gYWN0dWFsQ29tcG9uZW50cy5maWx0ZXIoYWN0dWFsID0+XG4gICAgICAgICAgTm90aWNlc0ZpbHRlci5jb21wb25lbnROYW1lTWF0Y2hlcyhhZmZlY3RlZCwgYWN0dWFsKSAmJiBzZW12ZXIuc2F0aXNmaWVzKGFjdHVhbC52ZXJzaW9uLCBhZmZlY3RlZC52ZXJzaW9uKSkpO1xuXG4gICAgICAgIC8vIEZvciBldmVyeSBjbGF1c2UgaW4gdGhlIGZpbHRlciB3ZSBtYXRjaGVkIG9uZSBvciBtb3JlIGNvbXBvbmVudHNcbiAgICAgICAgaWYgKG1hdGNoZWQuZXZlcnkoeHMgPT4geHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICBjb25zdCByZXQgPSBuZXcgRmlsdGVyZWROb3RpY2Uobm90aWNlKTtcbiAgICAgICAgICBOb3RpY2VzRmlsdGVyLmFkZER5bmFtaWNWYWx1ZXMobWF0Y2hlZC5mbGF0TWFwKHggPT4geCksIHJldCk7XG4gICAgICAgICAgcmV0dXJuIFtyZXRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBnaXZlbiBcImFmZmVjdGVkIGNvbXBvbmVudFwiIG5hbWUgYXBwbGllcyB0byB0aGUgZ2l2ZW4gYWN0dWFsIGNvbXBvbmVudCBuYW1lLlxuICAgKlxuICAgKiBUaGUgbmFtZSBtYXRjaGVzIGlmIHRoZSBuYW1lIGlzIGV4YWN0bHkgdGhlIHNhbWUsIG9yIHRoZSBuYW1lIGluIHRoZSBub3RpY2VcbiAgICogaXMgYSBwcmVmaXggb2YgdGhlIG5vZGUgbmFtZSB3aGVuIHRoZSBxdWVyeSBlbmRzIGluICcuJy5cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGNvbXBvbmVudE5hbWVNYXRjaGVzKHBhdHRlcm46IENvbXBvbmVudCwgYWN0dWFsOiBBY3R1YWxDb21wb25lbnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcGF0dGVybi5uYW1lLmVuZHNXaXRoKCcuJykgPyBhY3R1YWwubmFtZS5zdGFydHNXaXRoKHBhdHRlcm4ubmFtZSkgOiBwYXR0ZXJuLm5hbWUgPT09IGFjdHVhbC5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZHluYW1pYyB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gQWN0dWFsQ29tcG9uZW50c1xuICAgKlxuICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGR5bmFtaWMgbmFtZSwgdGhleSBhcmUgam9pbmVkXG4gICAqIGJ5IGEgY29tbWEuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBhZGREeW5hbWljVmFsdWVzKGNvbXBzOiBBY3R1YWxDb21wb25lbnRbXSwgbm90aWNlOiBGaWx0ZXJlZE5vdGljZSkge1xuICAgIGNvbnN0IGR5bmFtaWNWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHt9O1xuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wcykge1xuICAgICAgaWYgKGNvbXAuZHluYW1pY05hbWUpIHtcbiAgICAgICAgZHluYW1pY1ZhbHVlc1tjb21wLmR5bmFtaWNOYW1lXSA9IGR5bmFtaWNWYWx1ZXNbY29tcC5keW5hbWljTmFtZV0gPz8gW107XG4gICAgICAgIGR5bmFtaWNWYWx1ZXNbY29tcC5keW5hbWljTmFtZV0ucHVzaChjb21wLmR5bmFtaWNWYWx1ZSA/PyBjb21wLnZlcnNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgT2JqZWN0LmVudHJpZXMoZHluYW1pY1ZhbHVlcykpIHtcbiAgICAgIG5vdGljZS5hZGREeW5hbWljVmFsdWUoa2V5LCB2YWx1ZXMuam9pbignLCcpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJlYXQgJ2ZyYW1ld29yaycgYXMgYW4gYWxpYXMgZm9yIGVpdGhlciBgYXdzLWNkay1saWIuYCBvciBgQGF3cy1jZGsvY29yZS5gLlxuICAgKlxuICAgKiBCZWNhdXNlIGl0J3MgRUlUSEVSIGBhd3MtY2RrLWxpYmAgb3IgYEBhd3MtY2RrL2NvcmVgLCB3ZSBuZWVkIHRvIGFkZCBtdWx0aXBsZVxuICAgKiBhcnJheXMgYXQgdGhlIHRvcCBsZXZlbC5cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHJlc29sdmVBbGlhc2VzKG9yczogQ29tcG9uZW50W11bXSk6IENvbXBvbmVudFtdW10ge1xuICAgIHJldHVybiBvcnMuZmxhdE1hcChhbmRzID0+IHtcbiAgICAgIGNvbnN0IGhhc0ZyYW1ld29yayA9IGFuZHMuZmluZChjID0+IGMubmFtZSA9PT0gJ2ZyYW1ld29yaycpO1xuICAgICAgaWYgKCFoYXNGcmFtZXdvcmspIHtcbiAgICAgICAgcmV0dXJuIFthbmRzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYW5kcy5tYXAoYyA9PiBjLm5hbWUgPT09ICdmcmFtZXdvcmsnID8geyAuLi5jLCBuYW1lOiAnQGF3cy1jZGsvY29yZS4nIH0gOiBjKSxcbiAgICAgICAgYW5kcy5tYXAoYyA9PiBjLm5hbWUgPT09ICdmcmFtZXdvcmsnID8geyAuLi5jLCBuYW1lOiAnYXdzLWNkay1saWIuJyB9IDogYyksXG4gICAgICBdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIGNvbnN0cnVjdCB0cmVlIGZyb20gdGhlIGdpdmVuIGRpcmVjdG9yeSBhbmQgcmV0dXJuIGl0cyBjb21wb25lbnRzXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBjb25zdHJ1Y3RUcmVlQ29tcG9uZW50cyhtYW5pZmVzdERpcjogc3RyaW5nKTogQWN0dWFsQ29tcG9uZW50W10ge1xuICAgIGNvbnN0IHRyZWUgPSBsb2FkVHJlZUZyb21EaXIobWFuaWZlc3REaXIpO1xuICAgIGlmICghdHJlZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHJldDogQWN0dWFsQ29tcG9uZW50W10gPSBbXTtcbiAgICByZWN1cnNlKHRyZWUpO1xuICAgIHJldHVybiByZXQ7XG5cbiAgICBmdW5jdGlvbiByZWN1cnNlKHg6IENvbnN0cnVjdFRyZWVOb2RlKSB7XG4gICAgICBpZiAoeC5jb25zdHJ1Y3RJbmZvPy5mcW4gJiYgeC5jb25zdHJ1Y3RJbmZvPy52ZXJzaW9uKSB7XG4gICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICBuYW1lOiB4LmNvbnN0cnVjdEluZm8/LmZxbixcbiAgICAgICAgICB2ZXJzaW9uOiB4LmNvbnN0cnVjdEluZm8/LnZlcnNpb24sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIE9iamVjdC52YWx1ZXMoeC5jaGlsZHJlbiA/PyB7fSkpIHtcbiAgICAgICAgcmVjdXJzZShjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmludGVyZmFjZSBBY3R1YWxDb21wb25lbnQge1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgY29tcG9uZW50XG4gICAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFZlcnNpb24gb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgcmVhZG9ubHkgdmVyc2lvbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJZiBtYXRjaGVkLCB1bmRlciB3aGF0IG5hbWUgc2hvdWxkIGl0IGJlIGFkZGVkIHRvIHRoZSBzZXQgb2YgZHluYW1pYyB2YWx1ZXNcbiAgICpcbiAgICogVGhlc2Ugd2lsbCBiZSB1c2VkIHRvIHN1YnN0aXR1dGUgcGxhY2Vob2xkZXJzIGluIHRoZSBtZXNzYWdlIHN0cmluZywgd2hlcmVcbiAgICogcGxhY2Vob2xkZXJzIGxvb2sgbGlrZSBge3Jlc29sdmU6WFlafWAuXG4gICAqXG4gICAqIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgY29tcG9uZW50IHdpdGggdGhlIHNhbWUgZHluYW1pYyBuYW1lLCB0aGV5IGFyZVxuICAgKiBqb2luZWQgYnkgJywnLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERvbid0IGFkZCB0byB0aGUgc2V0IG9mIGR5bmFtaWMgdmFsdWVzLlxuICAgKi9cbiAgcmVhZG9ubHkgZHluYW1pY05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElmIG1hdGNoZWQsIHdoYXQgd2Ugc2hvdWxkIHB1dCBpbiB0aGUgc2V0IG9mIGR5bmFtaWMgdmFsdWVzIGluc3N0ZWFkIG9mIHRoZSB2ZXJzaW9uLlxuICAgKlxuICAgKiBPbmx5IHVzZWQgaWYgYGR5bmFtaWNOYW1lYCBpcyBzZXQ7IGJ5IGRlZmF1bHQgd2Ugd2lsbCBhZGQgdGhlIGFjdHVhbCB2ZXJzaW9uXG4gICAqIG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gVGhlIHZlcnNpb24uXG4gICAqL1xuICByZWFkb25seSBkeW5hbWljVmFsdWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgYSBib290c3RyYXBwZWQgZW52aXJvbm1lbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQm9vdHN0cmFwcGVkRW52aXJvbm1lbnQge1xuICByZWFkb25seSBib290c3RyYXBTdGFja1ZlcnNpb246IG51bWJlcjtcbiAgcmVhZG9ubHkgZW52aXJvbm1lbnQ6IEVudmlyb25tZW50O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byBub3RpY2VzIHRoZSBDTEkgY2FuIGRpc3BsYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RpY2VzIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoaXMgcmVwbGFjZXMgdGhlIHNpbmdsZXRvbi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlKHByb3BzOiBOb3RpY2VzUHJvcHMpOiBOb3RpY2VzIHtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyBOb3RpY2VzKHByb3BzKTtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaW5nbGV0b24gaW5zdGFuY2UuIE1heSByZXR1cm4gYHVuZGVmaW5lZGAgaWYgYGNyZWF0ZWAgaGFzIG5vdCBiZWVuIGNhbGxlZC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0KCk6IE5vdGljZXMgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIF9pbnN0YW5jZTogTm90aWNlcyB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHJlYWRvbmx5IGNvbnRleHQ6IENvbnRleHQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgb3V0cHV0OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2hvdWxkRGlzcGxheTogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBhY2tub3dsZWRnZWRJc3N1ZU51bWJlcnM6IFNldDxOdW1iZXI+O1xuICBwcml2YXRlIHJlYWRvbmx5IGluY2x1ZGVBY2tub3dsZWdkZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgaHR0cE9wdGlvbnM6IFNka0h0dHBPcHRpb25zO1xuXG4gIHByaXZhdGUgZGF0YTogU2V0PE5vdGljZT4gPSBuZXcgU2V0KCk7XG5cbiAgLy8gc2V0cyBkb24ndCBkZWR1cGxpY2F0ZSBpbnRlcmZhY2VzLCBzbyB3ZSB1c2UgYSBtYXAuXG4gIHByaXZhdGUgcmVhZG9ubHkgYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzOiBNYXA8c3RyaW5nLCBCb290c3RyYXBwZWRFbnZpcm9ubWVudD4gPSBuZXcgTWFwKCk7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcm9wczogTm90aWNlc1Byb3BzKSB7XG4gICAgdGhpcy5jb250ZXh0ID0gcHJvcHMuY29udGV4dDtcbiAgICB0aGlzLmFja25vd2xlZGdlZElzc3VlTnVtYmVycyA9IG5ldyBTZXQodGhpcy5jb250ZXh0LmdldCgnYWNrbm93bGVkZ2VkLWlzc3VlLW51bWJlcnMnKSA/PyBbXSk7XG4gICAgdGhpcy5pbmNsdWRlQWNrbm93bGVnZGVkID0gcHJvcHMuaW5jbHVkZUFja25vd2xlZGdlZCA/PyBmYWxzZTtcbiAgICB0aGlzLm91dHB1dCA9IHByb3BzLm91dHB1dCA/PyAnY2RrLm91dCc7XG4gICAgdGhpcy5zaG91bGREaXNwbGF5ID0gcHJvcHMuc2hvdWxkRGlzcGxheSA/PyB0cnVlO1xuICAgIHRoaXMuaHR0cE9wdGlvbnMgPSBwcm9wcy5odHRwT3B0aW9ucyA/PyB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBib290c3RyYXAgaW5mb3JtYXRpb24gdG8gZmlsdGVyIG9uLiBDYW4gaGF2ZSBtdWx0aXBsZSB2YWx1ZXNcbiAgICogaW4gY2FzZSBvZiBtdWx0aS1lbnZpcm9ubWVudCBkZXBsb3ltZW50cy5cbiAgICovXG4gIHB1YmxpYyBhZGRCb290c3RyYXBwZWRFbnZpcm9ubWVudChib290c3RyYXBwZWQ6IEJvb3RzdHJhcHBlZEVudmlyb25tZW50KSB7XG4gICAgY29uc3Qga2V5ID0gW1xuICAgICAgYm9vdHN0cmFwcGVkLmJvb3RzdHJhcFN0YWNrVmVyc2lvbixcbiAgICAgIGJvb3RzdHJhcHBlZC5lbnZpcm9ubWVudC5hY2NvdW50LFxuICAgICAgYm9vdHN0cmFwcGVkLmVudmlyb25tZW50LnJlZ2lvbixcbiAgICAgIGJvb3RzdHJhcHBlZC5lbnZpcm9ubWVudC5uYW1lLFxuICAgIF0uam9pbignOicpO1xuICAgIHRoaXMuYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzLnNldChrZXksIGJvb3RzdHJhcHBlZCk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgbGlzdCBvZiBub3RpY2VzIHRoaXMgaW5zdGFuY2UgaXMgYXdhcmUgb2YuXG4gICAqIFRvIG1ha2Ugc3VyZSB0aGlzIG5ldmVyIGNyYXNoZXMgdGhlIENMSSBwcm9jZXNzLCBhbGwgZmFpbHVyZXMgYXJlIGNhdWdodCBhbmRcbiAgICogc2lsZW50bHkgbG9nZ2VkLlxuICAgKlxuICAgKiBJZiBjb250ZXh0IGlzIGNvbmZpZ3VyZWQgdG8gbm90IGRpc3BsYXkgbm90aWNlcywgdGhpcyB3aWxsIG5vLW9wLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlZnJlc2gob3B0aW9uczogTm90aWNlc1JlZnJlc2hPcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuc2hvdWxkRGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB1bmRlcmx5aW5nRGF0YVNvdXJjZSA9IG9wdGlvbnMuZGF0YVNvdXJjZSA/PyBuZXcgV2Vic2l0ZU5vdGljZURhdGFTb3VyY2UodGhpcy5odHRwT3B0aW9ucyk7XG4gICAgICBjb25zdCBkYXRhU291cmNlID0gbmV3IENhY2hlZERhdGFTb3VyY2UoQ0FDSEVfRklMRV9QQVRILCB1bmRlcmx5aW5nRGF0YVNvdXJjZSwgb3B0aW9ucy5mb3JjZSA/PyBmYWxzZSk7XG4gICAgICBjb25zdCBub3RpY2VzID0gYXdhaXQgZGF0YVNvdXJjZS5mZXRjaCgpO1xuICAgICAgdGhpcy5kYXRhID0gbmV3IFNldCh0aGlzLmluY2x1ZGVBY2tub3dsZWdkZWQgPyBub3RpY2VzIDogbm90aWNlcy5maWx0ZXIobiA9PiAhdGhpcy5hY2tub3dsZWRnZWRJc3N1ZU51bWJlcnMuaGFzKG4uaXNzdWVOdW1iZXIpKSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBkZWJ1ZyhgQ291bGQgbm90IHJlZnJlc2ggbm90aWNlczogJHtlfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IHRoZSByZWxldmFudCBub3RpY2VzICh1bmxlc3MgY29udGV4dCBkaWN0YXRlcyB3ZSBzaG91bGRuJ3QpLlxuICAgKi9cbiAgcHVibGljIGRpc3BsYXkob3B0aW9uczogTm90aWNlc1ByaW50T3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLnNob3VsZERpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZE5vdGljZXMgPSBOb3RpY2VzRmlsdGVyLmZpbHRlcih7XG4gICAgICBkYXRhOiBBcnJheS5mcm9tKHRoaXMuZGF0YSksXG4gICAgICBjbGlWZXJzaW9uOiB2ZXJzaW9uTnVtYmVyKCksXG4gICAgICBvdXREaXI6IHRoaXMub3V0cHV0LFxuICAgICAgYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzOiBBcnJheS5mcm9tKHRoaXMuYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzLnZhbHVlcygpKSxcbiAgICB9KTtcblxuICAgIGlmIChmaWx0ZXJlZE5vdGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgaW5mbygnJyk7XG4gICAgICBpbmZvKCdOT1RJQ0VTICAgICAgICAgKFdoYXRcXCdzIHRoaXM/IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay93aWtpL0NMSS1Ob3RpY2VzKScpO1xuICAgICAgaW5mbygnJyk7XG4gICAgICBmb3IgKGNvbnN0IGZpbHRlcmVkIG9mIGZpbHRlcmVkTm90aWNlcykge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmaWx0ZXJlZC5mb3JtYXQoKTtcbiAgICAgICAgc3dpdGNoIChmaWx0ZXJlZC5ub3RpY2Uuc2V2ZXJpdHkpIHtcbiAgICAgICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgICAgIHdhcm5pbmcoZm9ybWF0dGVkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgIGVycm9yKGZvcm1hdHRlZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaW5mbyhmb3JtYXR0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGluZm8oJycpO1xuICAgICAgfVxuICAgICAgaW5mbyhgSWYgeW91IGRvbuKAmXQgd2FudCB0byBzZWUgYSBub3RpY2UgYW55bW9yZSwgdXNlIFwiY2RrIGFja25vd2xlZGdlIDxpZD5cIi4gRm9yIGV4YW1wbGUsIFwiY2RrIGFja25vd2xlZGdlICR7ZmlsdGVyZWROb3RpY2VzWzBdLm5vdGljZS5pc3N1ZU51bWJlcn1cIi5gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zaG93VG90YWwgPz8gZmFsc2UpIHtcbiAgICAgIGluZm8oJycpO1xuICAgICAgaW5mbyhgVGhlcmUgYXJlICR7ZmlsdGVyZWROb3RpY2VzLmxlbmd0aH0gdW5hY2tub3dsZWRnZWQgbm90aWNlKHMpLmApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBvbmVudCB7XG4gIG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJhbmdlIG9mIGFmZmVjdGVkIHZlcnNpb25zXG4gICAqL1xuICB2ZXJzaW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWNlIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgaXNzdWVOdW1iZXI6IG51bWJlcjtcbiAgb3ZlcnZpZXc6IHN0cmluZztcbiAgLyoqXG4gICAqIEEgc2V0IG9mIGFmZmVjdGVkIGNvbXBvbmVudHNcbiAgICpcbiAgICogVGhlIGNhbm9uaWNhbCBmb3JtIG9mIGEgbGlzdCBvZiBjb21wb25lbnRzIGlzIGluIERpc2p1bmN0aXZlIE5vcm1hbCBGb3JtXG4gICAqIChpLmUuLCBhbiBPUiBvZiBBTkRzKS4gVGhpcyBpcyB0aGUgZm9ybSB3aGVuIHRoZSBsaXN0IG9mIGNvbXBvbmVudHMgaXMgYVxuICAgKiBkb3VibHkgbmVzdGVkIGFycmF5OiB0aGUgbm90aWNlIG1hdGNoZXMgaWYgYWxsIGNvbXBvbmVudHMgb2YgYXQgbGVhc3Qgb25lXG4gICAqIG9mIHRoZSB0b3AtbGV2ZWwgYXJyYXkgbWF0Y2hlcy5cbiAgICpcbiAgICogSWYgdGhlIGBjb21wb25lbnRzYCBpcyBhIHNpbmdsZS1sZXZlbCBhcnJheSwgaXQgaXMgZXZhbHVhdGVkIGFzIGFuIE9SOyBpdFxuICAgKiBtYXRjaGVzIGlmIGFueSBvZiB0aGUgY29tcG9uZW50cyBtYXRjaGVzLlxuICAgKi9cbiAgY29tcG9uZW50czogQXJyYXk8Q29tcG9uZW50IHwgQ29tcG9uZW50W10+O1xuICBzY2hlbWFWZXJzaW9uOiBzdHJpbmc7XG4gIHNldmVyaXR5Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIGNvbXBvbmVudHMgc3RydWN0dXJlIGludG8gRE5GIGZvcm1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50cyh4czogQXJyYXk8Q29tcG9uZW50IHwgQ29tcG9uZW50W10+KTogQ29tcG9uZW50W11bXSB7XG4gIHJldHVybiB4cy5tYXAoeCA9PiBBcnJheS5pc0FycmF5KHgpID8geCA6IFt4XSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNvbmp1bmN0aW9uKHhzOiBDb21wb25lbnRbXSk6IHN0cmluZyB7XG4gIHJldHVybiB4cy5tYXAoYyA9PiBgJHtjLm5hbWV9OiAke2MudmVyc2lvbn1gKS5qb2luKCcgQU5EICcpO1xufVxuXG4vKipcbiAqIE5vdGljZSBhZnRlciBwYXNzaW5nIHRoZSBmaWx0ZXIuIEEgZmlsdGVyIGNhbiBhdWdtZW50IGEgbm90aWNlIHdpdGhcbiAqIGR5bmFtaWMgdmFsdWVzIGFzIGl0IGhhcyBhY2Nlc3MgdG8gdGhlIGR5bmFtaWMgbWF0Y2hpbmcgZGF0YS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcmVkTm90aWNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBkeW5hbWljVmFsdWVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBub3RpY2U6IE5vdGljZSkge1xuICB9XG5cbiAgcHVibGljIGFkZER5bmFtaWNWYWx1ZShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuZHluYW1pY1ZhbHVlc1tge3Jlc29sdmU6JHtrZXl9fWBdID0gdmFsdWU7XG4gIH1cblxuICBwdWJsaWMgZm9ybWF0KCk6IHN0cmluZyB7XG4gICAgY29uc3QgY29tcG9uZW50c1ZhbHVlID0gbm9ybWFsaXplQ29tcG9uZW50cyh0aGlzLm5vdGljZS5jb21wb25lbnRzKS5tYXAocmVuZGVyQ29uanVuY3Rpb24pLmpvaW4oJywgJyk7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZUR5bmFtaWNWYWx1ZXMoW1xuICAgICAgYCR7dGhpcy5ub3RpY2UuaXNzdWVOdW1iZXJ9XFx0JHt0aGlzLm5vdGljZS50aXRsZX1gLFxuICAgICAgdGhpcy5mb3JtYXRPdmVydmlldygpLFxuICAgICAgYFxcdEFmZmVjdGVkIHZlcnNpb25zOiAke2NvbXBvbmVudHNWYWx1ZX1gLFxuICAgICAgYFxcdE1vcmUgaW5mb3JtYXRpb24gYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvJHt0aGlzLm5vdGljZS5pc3N1ZU51bWJlcn1gLFxuICAgIF0uam9pbignXFxuXFxuJykgKyAnXFxuJyk7XG4gIH1cblxuICBwcml2YXRlIGZvcm1hdE92ZXJ2aWV3KCkge1xuICAgIGNvbnN0IHdyYXAgPSAoczogc3RyaW5nKSA9PiBzLnJlcGxhY2UoLyg/IVteXFxuXXsxLDYwfSQpKFteXFxuXXsxLDYwfSlcXHMvZywgJyQxXFxuJyk7XG5cbiAgICBjb25zdCBoZWFkaW5nID0gJ092ZXJ2aWV3OiAnO1xuICAgIGNvbnN0IHNlcGFyYXRvciA9IGBcXG5cXHQkeycgJy5yZXBlYXQoaGVhZGluZy5sZW5ndGgpfWA7XG4gICAgY29uc3QgY29udGVudCA9IHdyYXAodGhpcy5ub3RpY2Uub3ZlcnZpZXcpXG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAuam9pbihzZXBhcmF0b3IpO1xuXG4gICAgcmV0dXJuICdcXHQnICsgaGVhZGluZyArIGNvbnRlbnQ7XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVEeW5hbWljVmFsdWVzKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKE9iamVjdC5rZXlzKHRoaXMuZHluYW1pY1ZhbHVlcykuam9pbignfCcpLCAnZycpO1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKHBhdHRlcm4sIChtYXRjaGVkKSA9PiB0aGlzLmR5bmFtaWNWYWx1ZXNbbWF0Y2hlZF0gPz8gbWF0Y2hlZCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RpY2VEYXRhU291cmNlIHtcbiAgZmV0Y2goKTogUHJvbWlzZTxOb3RpY2VbXT47XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJzaXRlTm90aWNlRGF0YVNvdXJjZSBpbXBsZW1lbnRzIE5vdGljZURhdGFTb3VyY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFNka0h0dHBPcHRpb25zO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFNka0h0dHBPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgZmV0Y2goKTogUHJvbWlzZTxOb3RpY2VbXT4ge1xuICAgIGNvbnN0IHRpbWVvdXQgPSAzMDAwO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgcmVxOiBDbGllbnRSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuXG4gICAgICBsZXQgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgIHJlcS5kZXN0cm95KG5ldyBUb29sa2l0RXJyb3IoJ1JlcXVlc3QgdGltZWQgb3V0JykpO1xuICAgICAgICB9XG4gICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgdGltZXIudW5yZWYoKTtcblxuICAgICAgY29uc3Qgb3B0aW9uczogUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIGFnZW50OiBBd3NDbGlDb21wYXRpYmxlLnByb3h5QWdlbnQodGhpcy5vcHRpb25zKSxcbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcSA9IGh0dHBzLmdldCgnaHR0cHM6Ly9jbGkuY2RrLmRldi10b29scy5hd3MuZGV2L25vdGljZXMuanNvbicsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICByZXMgPT4ge1xuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgICAgICAgcmVzLnNldEVuY29kaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICAgIGxldCByYXdEYXRhID0gJyc7XG4gICAgICAgICAgICAgIHJlcy5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgIHJhd0RhdGEgKz0gY2h1bms7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UocmF3RGF0YSkubm90aWNlcyBhcyBOb3RpY2VbXTtcbiAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFwiJ25vdGljZXMnIGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVidWcoJ05vdGljZXMgcmVmcmVzaGVkJyk7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEgPz8gW10pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb29sa2l0RXJyb3IoYEZhaWxlZCB0byBwYXJzZSBub3RpY2VzOiAke2Zvcm1hdEVycm9yTWVzc2FnZShlKX1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzLm9uKCdlcnJvcicsIGUgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9vbGtpdEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbm90aWNlczogJHtmb3JtYXRFcnJvck1lc3NhZ2UoZSl9YCkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgVG9vbGtpdEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbm90aWNlcy4gU3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICByZXEub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICByZWplY3QobmV3IFRvb2xraXRFcnJvcihgSFRUUFMgJ2dldCcgY2FsbCB0aHJldyBhbiBlcnJvcjogJHtmb3JtYXRFcnJvck1lc3NhZ2UoZSl9YCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmludGVyZmFjZSBDYWNoZWROb3RpY2VzIHtcbiAgZXhwaXJhdGlvbjogbnVtYmVyO1xuICBub3RpY2VzOiBOb3RpY2VbXTtcbn1cblxuY29uc3QgVElNRV9UT19MSVZFX1NVQ0NFU1MgPSA2MCAqIDYwICogMTAwMDsgLy8gMSBob3VyXG5jb25zdCBUSU1FX1RPX0xJVkVfRVJST1IgPSAxICogNjAgKiAxMDAwOyAvLyAxIG1pbnV0ZVxuXG5leHBvcnQgY2xhc3MgQ2FjaGVkRGF0YVNvdXJjZSBpbXBsZW1lbnRzIE5vdGljZURhdGFTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpbGVOYW1lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBkYXRhU291cmNlOiBOb3RpY2VEYXRhU291cmNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2tpcENhY2hlPzogYm9vbGVhbikge1xuICB9XG5cbiAgYXN5bmMgZmV0Y2goKTogUHJvbWlzZTxOb3RpY2VbXT4ge1xuICAgIGNvbnN0IGNhY2hlZERhdGEgPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICBjb25zdCBkYXRhID0gY2FjaGVkRGF0YS5ub3RpY2VzO1xuICAgIGNvbnN0IGV4cGlyYXRpb24gPSBjYWNoZWREYXRhLmV4cGlyYXRpb24gPz8gMDtcblxuICAgIGlmIChEYXRlLm5vdygpID4gZXhwaXJhdGlvbiB8fCB0aGlzLnNraXBDYWNoZSkge1xuICAgICAgY29uc3QgZnJlc2hEYXRhID0gYXdhaXQgdGhpcy5mZXRjaElubmVyKCk7XG4gICAgICBhd2FpdCB0aGlzLnNhdmUoZnJlc2hEYXRhKTtcbiAgICAgIHJldHVybiBmcmVzaERhdGEubm90aWNlcztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoYFJlYWRpbmcgY2FjaGVkIG5vdGljZXMgZnJvbSAke3RoaXMuZmlsZU5hbWV9YCk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoSW5uZXIoKTogUHJvbWlzZTxDYWNoZWROb3RpY2VzPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cGlyYXRpb246IERhdGUubm93KCkgKyBUSU1FX1RPX0xJVkVfU1VDQ0VTUyxcbiAgICAgICAgbm90aWNlczogYXdhaXQgdGhpcy5kYXRhU291cmNlLmZldGNoKCksXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKGBDb3VsZCBub3QgcmVmcmVzaCBub3RpY2VzOiAke2V9YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHBpcmF0aW9uOiBEYXRlLm5vdygpICsgVElNRV9UT19MSVZFX0VSUk9SLFxuICAgICAgICBub3RpY2VzOiBbXSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb2FkKCk6IFByb21pc2U8Q2FjaGVkTm90aWNlcz4ge1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHtcbiAgICAgIGV4cGlyYXRpb246IDAsXG4gICAgICBub3RpY2VzOiBbXSxcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmcy5leGlzdHNTeW5jKHRoaXMuZmlsZU5hbWUpXG4gICAgICAgID8gYXdhaXQgZnMucmVhZEpTT04odGhpcy5maWxlTmFtZSkgYXMgQ2FjaGVkTm90aWNlc1xuICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZyhgRmFpbGVkIHRvIGxvYWQgbm90aWNlcyBmcm9tIGNhY2hlOiAke2V9YCk7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2F2ZShjYWNoZWQ6IENhY2hlZE5vdGljZXMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZnMud3JpdGVKU09OKHRoaXMuZmlsZU5hbWUsIGNhY2hlZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoYEZhaWxlZCB0byBzdG9yZSBub3RpY2VzIGluIHRoZSBjYWNoZTogJHtlfWApO1xuICAgIH1cbiAgfVxufVxuIl19